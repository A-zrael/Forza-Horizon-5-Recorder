<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Telemetry Player – Lapped / Sprint + Events</title>
<style>
  body{background:#0b0b0b;color:#eee;font-family:Arial,Helvetica,sans-serif;margin:0;padding:18px;text-align:center;}
  header{margin-bottom:10px;}
  .controls{margin:8px 0;display:flex;gap:8px;justify-content:center;flex-wrap:wrap;}
  .controls label{display:flex;align-items:center;gap:4px;font-size:13px;}
  input[type=file]{color:#fff;}
  #dashContainer{display:flex;flex-wrap:wrap;justify-content:center;gap:14px;margin-top:12px;}
  .dash{background:#111;padding:12px;border-radius:12px;width:360px;box-shadow:0 6px 20px rgba(0,0,0,0.6);}
  .dash h3{margin:0 0 6px 0;font-size:16px;}
  canvas{background:#000;border-radius:8px;display:block;margin:6px auto;}
  .gear{font-size:56px;font-weight:700;margin-top:6px;}
  .rpm-bar{width:260px;height:18px;background:#222;border-radius:12px;margin:8px auto;overflow:hidden;}
  .rpm-fill{height:100%;width:0%;background:linear-gradient(90deg,#7CFC00,#ffd700,#ff4500);}
  button{padding:8px 14px;margin:4px;font-size:14px;border-radius:8px;border:0;background:#222;color:#fff;cursor:pointer;}
  button.small{padding:6px 8px;font-size:13px;}
  input[type=range]{width:68%;margin-top:10px;}
  #legend{display:flex;justify-content:center;gap:12px;margin-top:8px;flex-wrap:wrap;}
  .legendItem{display:flex;gap:8px;align-items:center;font-size:13px;}
  .dot{width:14px;height:14px;border-radius:50%;display:inline-block;}
  #trackWrap{margin-top:16px;}
  #track{border-radius:12px;background:#000;box-shadow:inset 0 0 80px rgba(0,0,0,0.6);}
  #info{margin-top:8px;font-size:13px;color:#ddd;}
  #raceTypeInfo{margin-top:6px;font-size:13px;}
  table.timing{margin:8px auto;border-collapse:collapse;}
  table.timing td, table.timing th{padding:4px 6px;border:1px solid #222;font-size:11px;}
  table.timing th{background:#181818;}

  #eventTimeline{background:#050505;border-radius:8px;margin:10px auto;box-shadow:inset 0 0 40px rgba(0,0,0,0.8);}
  #eventTooltip{
    position:fixed;
    pointer-events:none;
    background:rgba(20,20,20,0.9);
    border:1px solid #444;
    border-radius:6px;
    padding:4px 8px;
    font-size:11px;
    color:#eee;
    display:none;
    z-index:9999;
  }
</style>
</head>
<body>
<header>
  <h1>Telemetry Player – Lapped / Sprint</h1>
  <div class="controls">
    <input type="file" id="csvInput" multiple accept=".csv"/>
    <button id="loadBtn">Load CSVs</button>
    <input type="file" id="masterJsonInput" accept=".json"/>
    <button id="useMasterBtn" class="small">Load Master JSON</button>
    <button id="exportMasterBtn" class="small">Export Master JSON</button>
    <button onclick="play()">▶ Play</button>
    <button onclick="pause()">⏸ Pause</button>
  </div>

  <div class="controls">
    <label><input type="checkbox" id="showSectors" checked> Show sectors</label>
    <label><input type="checkbox" id="showDeltas" checked> Show deltas</label>
    <label>Sectors:
      <select id="sectorCount">
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4" selected>4</option>
        <option value="5">5</option>
        <option value="6">6</option>
      </select>
    </label>
  </div>

  <div id="raceTypeInfo"></div>

  <div>
    <input type="range" id="scrubber" min="0" max="0" value="0"/>
  </div>

  <!-- Event timeline controls -->
  <div class="controls" id="eventControls">
    <span style="font-size:13px;">Timeline:</span>
    <button id="timelineUnified" class="small">Unified</button>
    <button id="timelinePerCar" class="small">Per-car</button>

    <label><input type="checkbox" id="showCrash" checked> Crash</label>
    <label><input type="checkbox" id="showCollision" checked> Collision</label>
    <label><input type="checkbox" id="showOvertake" checked> Overtake</label>
    <label><input type="checkbox" id="showFastLap" checked> Fastest Lap</label>
    <label><input type="checkbox" id="showLapStart" checked> Lap Start</label>
  </div>

  <canvas id="eventTimeline" width="900" height="80"></canvas>
  <div id="legend"></div>
  <div id="info">
    If no JSON is loaded, the master is built from telemetry. 
    Lapped = first lap averaged &amp; loop closed. Sprint = full run, no closure.
  </div>
</header>

<div id="dashContainer"></div>

<div id="trackWrap">
  <h2>Master Track</h2>
  <canvas id="track" width="900" height="900"></canvas>
</div>

<div id="eventTooltip"></div>

<script>
/* ---------- CONFIG ---------- */
const SAMPLES = 800;
const LAP_RADIUS = 20;
const LAP_MIN_SPEED = 8;
const MIN_LAP_SAMPLES = 300;
const ABS_EXCLUDE_M = 12;
const LOOP_CLOSE_FRACTION = 0.9;
const LOOP_MIN_GAP = 0.5;
const LOOP_DETECT_GAP = 40;

const colors = ["#00ffff","#ffa500","#ff66cc","#7CFC00","#ff8c00","#ff4444","#ffffff","#00bfff"];
const MIN_DT = 0.016, MAX_DT = 0.25;

/* Event detection thresholds */
const CRASH_SPEED_DROP_MPS = 9;   // ~20 mph
const CRASH_ACCEL_THRESH   = 8;   // m/s^2
const COLL_SPEED_DROP_MIN  = 3;   // ~7 mph
const COLL_SPEED_DROP_MAX  = 9;   // ~20 mph
const COLL_ACCEL_THRESH    = 6;
const EVENT_MIN_GAP_IDX    = 30;  // minimum frames between events of same type

/* ---------- STATE ---------- */
let cars = [];
let masterTrack = [];
let masterLockedFromJSON = false;

let playing = false;
let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;

// race type: 'lapped' or 'sprint'
let raceType = 'lapped';
let detectedRaceType = 'lapped';
let raceTypeOverridden = false;

let sectorCount = 4;

/* timeline mode: 'unified' | 'percar' */
let timelineMode = 'unified';

/* ---------- DOM ---------- */
const csvInput = document.getElementById("csvInput");
const loadBtn = document.getElementById("loadBtn");
const masterJsonInput = document.getElementById("masterJsonInput");
const useMasterBtn = document.getElementById("useMasterBtn");
const exportMasterBtn = document.getElementById("exportMasterBtn");
const scrubber = document.getElementById("scrubber");
const dashContainer = document.getElementById("dashContainer");
const legend = document.getElementById("legend");
const trackCanvas = document.getElementById("track");
const trackCtx = trackCanvas.getContext("2d");
const raceTypeInfo = document.getElementById("raceTypeInfo");
const showSectorsEl = document.getElementById("showSectors");
const showDeltasEl = document.getElementById("showDeltas");
const sectorCountEl = document.getElementById("sectorCount");
const eventCanvas = document.getElementById("eventTimeline");
const eventCtx = eventCanvas.getContext("2d");
const tooltipEl = document.getElementById("eventTooltip");

/* Event controls */
const timelineUnifiedBtn = document.getElementById("timelineUnified");
const timelinePerCarBtn = document.getElementById("timelinePerCar");
const showCrashEl     = document.getElementById("showCrash");
const showCollisionEl = document.getElementById("showCollision");
const showOvertakeEl  = document.getElementById("showOvertake");
const showFastLapEl   = document.getElementById("showFastLap");
const showLapStartEl  = document.getElementById("showLapStart");

/* ---------- HELPERS ---------- */
const safe = v => { const n = parseFloat(v); return Number.isFinite(n)?n:0; };
const clamp01 = x => Math.max(0, Math.min(1,x));
const basename = n => n.replace(/^.*[\\/]/,'').replace(/\.[^.]+$/,'');

function formatMs(ms){
  if(ms == null) return '-';
  const s = Math.floor(ms/1000);
  const msR = Math.floor(ms%1000);
  const mm = Math.floor(s/60);
  const ss = s%60;
  return `${mm}:${String(ss).padStart(2,'0')}.${String(msR).padStart(3,'0')}`;
}
function formatDeltaSec(ms){
  if(ms == null) return '-';
  if(ms === 0) return '+0.000s';
  const s = ms/1000;
  const sign = s>=0?'+':'-';
  const abs = Math.abs(s);
  return sign + abs.toFixed(3) + 's';
}

/* ---------- JSON MASTER IMPORT / EXPORT ---------- */
masterJsonInput.addEventListener("change", e=>{
  const f = e.target.files[0];
  if(!f) return;
  const r=new FileReader();
  r.onload = ev => {
    try{
      const obj = JSON.parse(ev.target.result);
      if(Array.isArray(obj.master)){
        masterTrack = obj.master;
        masterLockedFromJSON = true;
        ensureMasterDist();
        recomputeBoundsFromMaster();
        autoDetectRaceTypeFromMaster();
        updateRaceTypeUI();
        drawMasterTrack();
        if(cars.length){
          cars.forEach(updateCarTrackIndex);
          updateDashboards();
          drawCars();
          detectEventsAllCars();
          drawEventTimeline();
        }
        alert("Master track loaded from JSON and locked.");
      } else alert("Invalid master JSON.");
    }catch(err){ alert("Invalid JSON file."); }
  };
  r.readAsText(f);
});
useMasterBtn.onclick = ()=> masterJsonInput.click();

exportMasterBtn.onclick = ()=>{
  if(!masterTrack.length) return alert("No master to export yet.");
  const blob = new Blob([JSON.stringify({master: masterTrack})],{type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "master_track.json";
  a.click();
  URL.revokeObjectURL(url);
};

/* ---------- RACE TYPE UI ---------- */
function updateRaceTypeUI(){
  const detText = detectedRaceType === 'lapped'
    ? 'Lapped (circuit race)'
    : 'Sprint (point-to-point)';
  const showType = raceType === 'lapped'
    ? 'Lapped (circuit race)'
    : 'Sprint (point-to-point)';
  const other = raceType === 'lapped' ? 'Sprint' : 'Lapped';
  raceTypeInfo.innerHTML =
    `Detected: ${detText} &nbsp; | &nbsp; Current mode: <b>${showType}</b> 
     &nbsp; <button id="raceToggleBtn" class="small">Switch to ${other}</button>`;
  const btn = document.getElementById("raceToggleBtn");
  if(btn){
    btn.onclick = ()=>{
      raceType = (raceType === 'lapped') ? 'sprint' : 'lapped';
      raceTypeOverridden = true;
      updateRaceTypeUI();
      if(!masterLockedFromJSON){
        buildMasterFromTelemetry();
      }
      drawMasterTrack();
      cars.forEach(updateCarTrackIndex);
      updateDashboards();
      drawCars();
      detectEventsAllCars();
      drawEventTimeline();
    };
  }
}

/* ---------- AUTO-DETECT RACE TYPE ---------- */
function autoDetectRaceTypeFromCars(){
  if(!cars.length) return;
  const car = cars[0];
  const d = car.data;
  if(!d.length) return;
  const start = d[0];
  const end   = d[d.length-1];
  const gap = Math.hypot(end.pos_x - start.pos_x, end.pos_y - start.pos_y);
  const hasMultipleLaps = car.lapStarts && car.lapStarts.length > 1;
  let guess;
  if(gap < LOOP_DETECT_GAP && hasMultipleLaps){
    guess = 'lapped';
  } else {
    guess = 'sprint';
  }
  detectedRaceType = guess;
  if(!raceTypeOverridden){
    raceType = guess;
  }
  updateRaceTypeUI();
}

function autoDetectRaceTypeFromMaster(){
  if(!masterTrack.length) return;
  const first = masterTrack[0];
  const last  = masterTrack[masterTrack.length-1];
  const gap = Math.hypot(last.x - first.x, last.y - first.y);
  detectedRaceType = (gap < LOOP_DETECT_GAP ? 'lapped' : 'sprint');
  if(!raceTypeOverridden){
    raceType = detectedRaceType;
  }
  updateRaceTypeUI();
}

/* ---------- UI EVENTS: SECTORS / DELTAS ---------- */
showSectorsEl.addEventListener("change", ()=> updateDashboards());
showDeltasEl.addEventListener("change", ()=> updateDashboards());
sectorCountEl.addEventListener("change", ()=>{
  sectorCount = parseInt(sectorCountEl.value,10) || 4;
  updateDashboards();
});

/* ---------- UI EVENTS: TIMELINE MODE & FILTERS ---------- */
timelineUnifiedBtn.onclick = ()=>{
  timelineMode = 'unified';
  drawEventTimeline();
};
timelinePerCarBtn.onclick = ()=>{
  timelineMode = 'percar';
  drawEventTimeline();
};

[showCrashEl, showCollisionEl, showOvertakeEl, showFastLapEl, showLapStartEl].forEach(el=>{
  el.addEventListener("change", ()=> drawEventTimeline());
});

/* ---------- LOAD CSVs ---------- */
loadBtn.onclick = () => {
  if(!csvInput.files.length) return alert("Choose CSV files first");
  startLoad([...csvInput.files].slice(0,8));
};

function startLoad(files){
  cars = [];
  dashContainer.innerHTML = "";
  legend.innerHTML = "";
  tooltipEl.style.display = "none";

  if(!masterLockedFromJSON){
    masterTrack = [];
    minX=Infinity;maxX=-Infinity;minY=Infinity;maxY=-Infinity;
  }

  let readers = files.map((f,idx)=> new Promise((res,rej)=>{
    const r=new FileReader();
    r.onload = ev => res({text:ev.target.result,name:f.name, idx});
    r.onerror = rej;
    r.readAsText(f);
  }));
  Promise.all(readers).then(list=>{
    list.forEach(f=>parseCSV(f.text,f.name,f.idx));
    detectLapsForAll();
    if(!masterLockedFromJSON){
      autoDetectRaceTypeFromCars();
      buildMasterFromTelemetry();
    } else {
      ensureMasterDist();
      recomputeBoundsFromMaster();
      autoDetectRaceTypeFromMaster();
    }
    createDashboards();
    updateLegend();
    drawMasterTrack();
    setupScrubber();
    cars.forEach(c=>c.events = []);
    detectEventsAllCars();
    drawEventTimeline();
  }).catch(err=>alert("File load error: "+err));
}

/* ---------- CSV PARSE + POS RECON ---------- */
function parseCSV(text,name,idx){
  const rows = text.trim().split("\n").filter(r=>r.trim());
  if(rows.length<2) return;
  const headers = rows.shift().split(",").map(h=>h.trim());
  const data = rows.map(r=>{
    const vals = r.split(",");
    const o = {};
    headers.forEach((h,i)=> o[h] = safe(vals[i]));
    if(!("timestampMS" in o)){
      const k1 = headers.indexOf("timestampMS");
      const k2 = headers.indexOf("timestamp");
      o.timestampMS = safe(vals[k1>=0?k1:k2>=0?k2:0]);
    }
    return o;
  });

  let x=0,y=0,heading=0,dist=0;
  data[0].pos_x=0; data[0].pos_y=0; data[0].dist=0;

  for(let i=1;i<data.length;i++){
    const prev=data[i-1], cur=data[i];
    let dt=(cur.timestampMS - prev.timestampMS)/1000;
    if(!isFinite(dt) || dt<=0 || dt>MAX_DT) dt=MIN_DT;

    if(cur.smooth_ax === undefined) cur.smooth_ax = cur.accel_x || 0;
    cur.smooth_ax = cur.smooth_ax*0.85 + (cur.accel_x||0)*0.15;

    const speed = Math.max(cur.speed_mps || 0, 0.1);
    let yawRate=0;
    if(speed>2) yawRate = cur.smooth_ax / speed;

    heading += yawRate*dt;

    const dx = Math.cos(heading)*speed*dt;
    const dy = Math.sin(heading)*speed*dt;
    x += dx; y += dy; dist += Math.hypot(dx,dy);

    cur.pos_x = x;
    cur.pos_y = y;
    cur.dist  = dist;
  }

  const totalDist = data[data.length-1].dist || 1;
  const speedScale = Math.max(...data.map(p=>p.speed_mph||0))*1.05 || 100;

  cars.push({
    name: basename(name),
    color: colors[idx % colors.length],
    data,
    dataIndex: 0,
    index: 0,
    totalDist,
    speedScale,
    lapStarts: [],
    lapLen: null,
    sectorBox: null,
    lapEl: null,
    events: []
  });
}

/* ---------- LAP DETECTION (PER CAR) ---------- */
function detectLapsForAll(){
  cars.forEach(car=>{
    const d = car.data;
    if(!d.length) { car.lapStarts=[0]; return; }
    const startX = d[0].pos_x;
    const startY = d[0].pos_y;
    const laps=[0];
    let lastIdx=0;

    for(let i=1;i<d.length;i++){
      const dx = d[i].pos_x - startX;
      const dy = d[i].pos_y - startY;
      const dist0 = Math.hypot(dx,dy);
      const speed = d[i].speed_mps || (d[i].speed_kph/3.6) || (d[i].speed_mph/2.23694) || 0;
      if(dist0 < LAP_RADIUS && speed > LAP_MIN_SPEED && (i-lastIdx) > MIN_LAP_SAMPLES){
        laps.push(i);
        lastIdx = i;
      }
    }
    car.lapStarts = laps;
    if(laps.length>1){
      car.lapLen = d[laps[1]].dist - d[laps[0]].dist;
    } else {
      car.lapLen = (d[d.length-1].dist - d[0].dist) || 1;
    }
  });
}

/* ---------- MASTER BUILD ---------- */
function buildMasterFromTelemetry(){
  if(!cars.length) return;
  masterTrack = [];
  minX=Infinity; maxX=-Infinity; minY=Infinity; maxY=-Infinity;

  let segments;

  if(raceType === 'lapped'){
    segments = cars.map(car=>{
      const d = car.data;
      const laps = car.lapStarts;
      const startIdx = laps[0] || 0;
      const endIdx = (laps[1] ? laps[1] : d.length-1);
      const seg = d.slice(startIdx, endIdx+1).map(p=>({x:p.pos_x,y:p.pos_y}));
      let lapDist=[0]; let acc=0;
      for(let i=1;i<seg.length;i++){
        const dx=seg[i].x-seg[i-1].x;
        const dy=seg[i].y-seg[i-1].y;
        acc += Math.hypot(dx,dy);
        lapDist[i]=acc;
      }
      const lapLen = lapDist[lapDist.length-1] || 1;
      return {seg, lapDist, lapLen};
    });
  } else {
    segments = cars.map(car=>{
      const d = car.data;
      const seg = d.map(p=>({x:p.pos_x,y:p.pos_y}));
      let lapDist=[0]; let acc=0;
      for(let i=1;i<seg.length;i++){
        const dx=seg[i].x-seg[i-1].x;
        const dy=seg[i].y-seg[i-1].y;
        acc += Math.hypot(dx,dy);
        lapDist[i]=acc;
      }
      const lapLen = lapDist[lapDist.length-1] || 1;
      return {seg, lapDist, lapLen};
    });
  }

  function posAtDist(segObj, target){
    const seg = segObj.seg;
    const lapDist = segObj.lapDist;
    if(target <= 0) return seg[0];
    if(target >= segObj.lapLen) return seg[seg.length-1];
    let lo=0, hi=lapDist.length-1;
    while(lo<hi){
      const mid=(lo+hi)>>1;
      if(lapDist[mid] < target) lo=mid+1; else hi=mid;
    }
    const hiIdx = Math.min(lo, lapDist.length-1);
    const loIdx = Math.max(0, hiIdx-1);
    const a = seg[loIdx], b = seg[hiIdx];
    const span = (lapDist[hiIdx] - lapDist[loIdx]) || 1e-6;
    const t = (target - lapDist[loIdx]) / span;
    return { x: a.x + (b.x-a.x)*t, y: a.y + (b.y-a.y)*t };
  }

  for(let i=0;i<SAMPLES;i++){
    const frac = i/(SAMPLES-1);
    const pts = segments.map(s => posAtDist(s, frac * s.lapLen));

    let mx=0,my=0;
    pts.forEach(p=>{mx+=p.x;my+=p.y;});
    mx/=pts.length; my/=pts.length;

    const dists = pts.map(p=>Math.hypot(p.x-mx,p.y-my));
    const filtered = [];
    for(let j=0;j<pts.length;j++){
      if(dists[j] <= ABS_EXCLUDE_M) filtered.push(pts[j]);
    }
    const use = filtered.length ? filtered : pts;

    let ax=0,ay=0;
    use.forEach(p=>{ax+=p.x;ay+=p.y;});
    ax/=use.length; ay/=use.length;

    masterTrack.push({x:ax,y:ay});
  }

  recomputeBoundsFromMaster();
  ensureMasterDist();

  if(raceType === 'lapped'){
    closeMasterLoopSmooth();
  }
}

/* ---------- MASTER DIST + BOUNDS ---------- */
function ensureMasterDist(){
  if(!masterTrack.length) return;
  let acc=0;
  masterTrack[0].dist = 0;
  for(let i=1;i<masterTrack.length;i++){
    const dx = masterTrack[i].x-masterTrack[i-1].x;
    const dy = masterTrack[i].y-masterTrack[i-1].y;
    acc += Math.hypot(dx,dy);
    masterTrack[i].dist = acc;
  }
}
function recomputeBoundsFromMaster(){
  if(!masterTrack.length) return;
  minX=Infinity;maxX=-Infinity;minY=Infinity;maxY=-Infinity;
  masterTrack.forEach(p=>{
    minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
    minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
  });
  if(minX===maxX){minX-=1;maxX+=1;}
  if(minY===maxY){minY-=1;maxY+=1;}
}

/* ---------- SMOOTH LOOP CLOSURE ---------- */
function closeMasterLoopSmooth(){
  if(!masterTrack.length) return;
  const n = masterTrack.length;
  if(n < 4) return;

  const first = masterTrack[0];
  const last  = masterTrack[n-1];
  const gapX = first.x - last.x;
  const gapY = first.y - last.y;
  const gapMag = Math.hypot(gapX,gapY);
  if(gapMag < LOOP_MIN_GAP) return;

  const startIdx = Math.floor(n * LOOP_CLOSE_FRACTION);
  if(startIdx >= n-1) return;
  const lastIdx = n-1;
  const length  = lastIdx - startIdx;
  if(length <= 0) return;

  for(let i=startIdx; i<=lastIdx; i++){
    const t = (i - startIdx) / length;
    masterTrack[i].x += gapX * t;
    masterTrack[i].y += gapY * t;
  }

  ensureMasterDist();
  recomputeBoundsFromMaster();
}

/* ---------- UI: DASH + LEGEND ---------- */
function createDashboards(){
  dashContainer.innerHTML = "";
  cars.forEach((car,i)=>{
    const d=document.createElement("div");
    d.className="dash";
    d.innerHTML = `
      <h3 style="color:${car.color}">${car.name}</h3>
      <canvas id="spd_${i}" width="260" height="260"></canvas>
      <div class="gear" id="gear_${i}">N</div>
      <div class="rpm-bar"><div class="rpm-fill" id="rpm_${i}"></div></div>
      <div id="lap_${i}" style="font-size:12px;margin-top:4px;"></div>
      <div id="sectorBox_${i}"></div>
    `;
    dashContainer.appendChild(d);
    car.ctx         = document.getElementById("spd_"+i).getContext("2d");
    car.gearEl      = document.getElementById("gear_"+i);
    car.rpmEl       = document.getElementById("rpm_"+i);
    car.lapEl       = document.getElementById("lap_"+i);
    car.sectorBox   = document.getElementById("sectorBox_"+i);
    car.dataIndex   = 0;
    car.index       = 0;
  });
}

function updateLegend(){
  legend.innerHTML="";
  cars.forEach(c=>{
    const div=document.createElement("div");
    div.className="legendItem";
    div.innerHTML = `<span class="dot" style="background:${c.color}"></span> ${c.name}`;
    legend.appendChild(div);
  });
}

/* ---------- PLAYBACK & SCRUBBER ---------- */
function setupScrubber(){
  const maxFrames = Math.max(...cars.map(c=>c.data.length));
  scrubber.max = Math.max(0, maxFrames-1);
  scrubber.value = 0;
}

function play(){ playing=true; loop(); }
function pause(){ playing=false; }

function loop(){
  if(!playing) return;
  cars.forEach(car=>{
    if(car.dataIndex < car.data.length-1) car.dataIndex++;
    updateCarTrackIndex(car);
  });

  const maxIdx = Math.max(...cars.map(c=>c.dataIndex));
  scrubber.value = maxIdx;

  updateDashboards();
  drawCars();
  drawEventTimeline();
  requestAnimationFrame(loop);
}

scrubber.addEventListener("input", e=>{
  const v = parseInt(e.target.value);
  cars.forEach(car=>{
    car.dataIndex = Math.min(v, car.data.length-1);
    updateCarTrackIndex(car);
  });
  updateDashboards();
  drawCars();
  drawEventTimeline();
});

/* ---------- MAP CAR → MASTER TRACK ---------- */
function updateCarTrackIndex(car){
  const d = car.data;
  if(!d.length || !masterTrack.length) { car.index=0; return; }

  const idx = car.dataIndex;
  const laps = car.lapStarts && car.lapStarts.length?car.lapStarts:[0];

  let lapIdx = 0;
  for(let i=laps.length-1;i>=0;i--){
    if(idx >= laps[i]) { lapIdx=i; break; }
  }

  const lapStartIdx = laps[lapIdx];
  const lapStartDist = d[lapStartIdx].dist;
  let lapEndDist;
  if(lapIdx+1 < laps.length){
    lapEndDist = d[laps[lapIdx+1]].dist;
  } else {
    lapEndDist = d[d.length-1].dist;
  }

  const lapLen = Math.max(1e-6, lapEndDist - lapStartDist);
  const lapDistWithin = d[idx].dist - lapStartDist;
  const frac = clamp01(lapDistWithin / lapLen);

  const masterLen = masterTrack[masterTrack.length-1].dist || 1;
  const target = frac * masterLen;

  let lo=0, hi=masterTrack.length-1;
  while(lo<hi){
    const mid=(lo+hi)>>1;
    if(masterTrack[mid].dist < target) lo=mid+1; else hi=mid;
  }
  car.index = lo;
}

/* ---------- LAP / SECTOR ANALYSIS (PER CAR) ---------- */
function computeLapAnalysisForCar(car){
  const d = car.data;
  if(!d.length || sectorCount <= 0) return null;

  let lapDefs = [];
  const starts = car.lapStarts && car.lapStarts.length ? car.lapStarts : [0];

  if(raceType === 'lapped' && starts.length > 1){
    for(let l=0;l<starts.length-1;l++){
      const s = starts[l];
      const e = (l+1 < starts.length ? starts[l+1]-1 : d.length-1);
      if(e > s) lapDefs.push({startIndex:s,endIndex:e});
    }
  } else {
    lapDefs.push({startIndex:0,endIndex:d.length-1});
  }

  if(!lapDefs.length) return null;

  const laps = [];
  let bestLapIndex = 0;
  let bestLapTimeMs = null;

  lapDefs.forEach((def,lapIdx)=>{
    const sIdx = def.startIndex;
    const eIdx = def.endIndex;
    const startTime = d[sIdx].timestampMS || 0;
    const endTime   = d[eIdx].timestampMS || startTime;
    const lapTimeMs = Math.max(0, endTime - startTime);

    const startDist = d[sIdx].dist;
    const endDist   = d[eIdx].dist;
    const lapLen    = Math.max(1e-6, endDist - startDist);

    const boundaryTimes = [startTime];
    for(let s=1;s<=sectorCount;s++){
      const targetDist = startDist + (s/sectorCount)*lapLen;
      let i = sIdx;
      while(i<=eIdx && d[i].dist < targetDist) i++;
      let ts;
      if(i<=sIdx){
        ts = startTime;
      } else if(i>eIdx){
        ts = endTime;
      } else {
        const a = d[i-1], b = d[i];
        const span = (b.dist - a.dist) || 1e-6;
        const t = (targetDist - a.dist)/span;
        ts = a.timestampMS + t*(b.timestampMS - a.timestampMS);
      }
      boundaryTimes.push(ts);
    }

    const sectorTimesMs = [];
    for(let s=0;s<sectorCount;s++){
      const dt = boundaryTimes[s+1] - boundaryTimes[s];
      sectorTimesMs.push(Math.max(0, dt));
    }

    laps.push({startIndex:sIdx,endIndex:eIdx,lapTimeMs,sectorTimesMs});

    if(bestLapTimeMs === null || lapTimeMs < bestLapTimeMs){
      bestLapTimeMs = lapTimeMs;
      bestLapIndex = lapIdx;
    }
  });

  const bestSectorTimesMs = laps[bestLapIndex].sectorTimesMs.slice();
  return {laps,bestLapIndex,bestLapTimeMs,bestSectorTimesMs};
}

/* ---------- RENDER LAP/SECTOR TABLES ---------- */
function renderAnalysisTables(){
  const showSectors = showSectorsEl.checked;
  const showDeltas  = showDeltasEl.checked;

  cars.forEach(c => { if(c.sectorBox) c.sectorBox.innerHTML = ""; });
  if(!showSectors || !cars.length || sectorCount <= 0) return;

  cars.forEach(car=>{
    const box = car.sectorBox;
    if(!box) return;
    const analysis = computeLapAnalysisForCar(car);
    if(!analysis) return;

    const laps = analysis.laps;
    const lapCount = laps.length;
    const bestLapTimeMs = analysis.bestLapTimeMs;
    const bestSectorTimesMs = analysis.bestSectorTimesMs;

    const tbl = document.createElement("table");
    tbl.className = "timing";

    const hdr = document.createElement("tr");
    let hdrHtml = "<th></th>";
    for(let i=0;i<lapCount;i++) hdrHtml += `<th>Lap ${i+1}</th>`;
    hdrHtml += "<th>Best Lap</th>";
    hdr.innerHTML = hdrHtml;
    tbl.appendChild(hdr);

    for(let s=0;s<sectorCount;s++){
      const rowT = document.createElement("tr");
      let rowTHtml = `<td>S${s+1}</td>`;
      for(let l=0;l<lapCount;l++){
        rowTHtml += `<td>${formatMs(laps[l].sectorTimesMs[s])}</td>`;
      }
      rowTHtml += `<td>${formatMs(bestSectorTimesMs[s])}</td>`;
      rowT.innerHTML = rowTHtml;
      tbl.appendChild(rowT);

      if(showDeltas){
        const rowD = document.createElement("tr");
        let rowDHtml = `<td>ΔS${s+1}</td>`;
        for(let l=0;l<lapCount;l++){
          const st = laps[l].sectorTimesMs[s];
          const bst = bestSectorTimesMs[s];
          const delta = (st!=null && bst!=null) ? (st - bst) : null;
          rowDHtml += `<td>${formatDeltaSec(delta)}</td>`;
        }
        rowDHtml += `<td></td>`;
        rowD.innerHTML = rowDHtml;
        tbl.appendChild(rowD);
      }
    }

    const rowLap = document.createElement("tr");
    let rowLapHtml = "<td>Lap</td>";
    for(let l=0;l<lapCount;l++){
      rowLapHtml += `<td>${formatMs(laps[l].lapTimeMs)}</td>`;
    }
    rowLapHtml += `<td>${formatMs(bestLapTimeMs)}</td>`;
    rowLap.innerHTML = rowLapHtml;
    tbl.appendChild(rowLap);

    if(showDeltas){
      const rowLapD = document.createElement("tr");
      let rowLapDHtml = "<td>ΔLap</td>";
      for(let l=0;l<lapCount;l++){
        const delta = laps[l].lapTimeMs - bestLapTimeMs;
        rowLapDHtml += `<td>${formatDeltaSec(delta)}</td>`;
      }
      rowLapDHtml += "<td></td>";
      rowLapD.innerHTML = rowLapDHtml;
      tbl.appendChild(rowLapD);
    }

    box.appendChild(tbl);
  });
}

/* ---------- DASH UPDATE ---------- */
function updateDashboards(){
  cars.forEach(car=>{
    const p = car.data[Math.min(car.dataIndex, car.data.length-1)];
    drawSpeedo(car.ctx, p.speed_mph || 0, car.speedScale || 120);
    car.gearEl.textContent = ("gear" in p && p.gear !== 0) ? String(p.gear) : "N";
    const rpmPct = (p.engine_rpm && p.engine_max_rpm) ? (p.engine_rpm/p.engine_max_rpm) : 0;
    car.rpmEl.style.width = Math.max(0,Math.min(100,rpmPct*100))+"%";

    if(car.lapEl){
      const t0 = car.data[0].timestampMS || 0;
      const tNow = p.timestampMS || 0;
      car.lapEl.textContent = "Elapsed: " + formatMs(Math.max(0,tNow - t0));
    }
  });

  renderAnalysisTables();
}

/* ---------- SPEEDO ---------- */
function drawSpeedo(ctx, speed, maxSpeed){
  ctx.clearRect(0,0,260,260);
  const cx=130,cy=150,r=100;
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI,0);
  ctx.strokeStyle="#444"; ctx.lineWidth=8; ctx.stroke();
  const pct = clamp01(speed/(maxSpeed || 120));
  const ang = Math.PI + pct * Math.PI;
  ctx.beginPath(); ctx.moveTo(cx,cy);
  ctx.lineTo(cx+Math.cos(ang)*r, cy+Math.sin(ang)*r);
  ctx.strokeStyle="red"; ctx.lineWidth=4; ctx.stroke();
  ctx.fillStyle="#fff"; ctx.font="20px Arial"; ctx.textAlign="center";
  ctx.fillText(Math.round(speed)+" MPH", cx, 235);
}

/* ---------- TRACK DRAWING ---------- */
function worldToCanvas(x,y){
  const pad = 40;
  const sx = (trackCanvas.width - pad*2) / (maxX-minX || 1);
  const sy = (trackCanvas.height - pad*2) / (maxY-minY || 1);
  const s = Math.min(sx,sy);
  return {
    x: pad + (x-minX)*s,
    y: trackCanvas.height - (pad + (y-minY)*s)
  };
}

function drawMasterTrack(){
  if(!masterTrack.length) return;
  trackCtx.clearRect(0,0,trackCanvas.width,trackCanvas.height);
  trackCtx.globalAlpha=0.25;
  for(let i=1;i<masterTrack.length;i++){
    const a = worldToCanvas(masterTrack[i-1].x, masterTrack[i-1].y);
    const b = worldToCanvas(masterTrack[i].x,   masterTrack[i].y);
    trackCtx.beginPath();
    trackCtx.moveTo(a.x,a.y);
    trackCtx.lineTo(b.x,b.y);
    trackCtx.strokeStyle="#888";
    trackCtx.lineWidth=3;
    trackCtx.stroke();
  }
  trackCtx.globalAlpha = 1.0;

  const n = masterTrack.length;
  const start = worldToCanvas(masterTrack[0].x, masterTrack[0].y);
  const end   = worldToCanvas(masterTrack[n-1].x, masterTrack[n-1].y);

  if(raceType === 'lapped'){
    trackCtx.beginPath();
    trackCtx.arc(start.x, start.y, 6, 0, Math.PI*2);
    trackCtx.fillStyle = "#ffffff";
    trackCtx.fill();
  } else {
    trackCtx.beginPath();
    trackCtx.arc(start.x, start.y, 6, 0, Math.PI*2);
    trackCtx.fillStyle = "#00ff00";
    trackCtx.fill();
    trackCtx.beginPath();
    trackCtx.arc(end.x, end.y, 6, 0, Math.PI*2);
    trackCtx.fillStyle = "#ff4444";
    trackCtx.fill();
  }
}

function drawCars(){
  drawMasterTrack();
  cars.forEach(car=>{
    const idx = Math.max(0,Math.min(masterTrack.length-1, car.index));
    const p = masterTrack[idx] || masterTrack[0] || {x:0,y:0};
    const c = worldToCanvas(p.x,p.y);

    trackCtx.beginPath();
    for(let t=Math.max(0,idx-8); t<=idx; t++){
      const pt = masterTrack[t] || p;
      const cp = worldToCanvas(pt.x,pt.y);
      if(t===Math.max(0,idx-8)) trackCtx.moveTo(cp.x,cp.y);
      else trackCtx.lineTo(cp.x,cp.y);
    }
    trackCtx.strokeStyle = car.color;
    trackCtx.lineWidth = 3;
    trackCtx.stroke();

    trackCtx.beginPath();
    trackCtx.arc(c.x, c.y, 7, 0, Math.PI*2);
    trackCtx.fillStyle = car.color;
    trackCtx.fill();
  });
}

/* ---------- EVENT DETECTION ---------- */
function detectEventsAllCars(){
  // reset
  cars.forEach(c => c.events = []);

  // lap start + fastest lap per car
  cars.forEach(car=>{
    const d = car.data;
    const starts = car.lapStarts && car.lapStarts.length ? car.lapStarts : [0];

    // lap start events
    starts.forEach((idx,lapIdx)=>{
      car.events.push({
        type:"lapStart",
        idx,
        lap: lapIdx+1,
        label:`Lap ${lapIdx+1} start`
      });
    });

    // fastest lap event (using analysis)
    const analysis = computeLapAnalysisForCar(car);
    if(analysis){
      const laps = analysis.laps;
      const bestLapIndex = analysis.bestLapIndex;
      const lapDefs = [];

      if(raceType === 'lapped' && starts.length>1){
        for(let l=0;l<starts.length-1;l++){
          const s = starts[l];
          const e = (l+1 < starts.length ? starts[l+1]-1 : d.length-1);
          if(e > s) lapDefs.push({startIndex:s,endIndex:e});
        }
      } else {
        lapDefs.push({startIndex:0,endIndex:d.length-1});
      }

      if(lapDefs[bestLapIndex]){
        const startIdx = lapDefs[bestLapIndex].startIndex;
        car.events.push({
          type:"fastestLap",
          idx:startIdx,
          lap: bestLapIndex+1,
          label:`Fastest lap: Lap ${bestLapIndex+1} (${formatMs(analysis.bestLapTimeMs)})`
        });
      }
    }
  });

  // crash / collision events per car
  cars.forEach(car=>{
    const d = car.data;
    let lastCrashIdx = -Infinity;
    let lastCollIdx  = -Infinity;

    for(let i=1;i<d.length;i++){
      const prev = d[i-1];
      const cur  = d[i];
      const speedPrev = prev.speed_mps || (prev.speed_kph/3.6) || (prev.speed_mph/2.23694) || 0;
      const speedCur  = cur.speed_mps || (cur.speed_kph/3.6) || (cur.speed_mph/2.23694) || 0;
      const dv = speedPrev - speedCur; // drop
      const ax = cur.accel_x || 0;
      const ay = cur.accel_y || 0;
      const aMag = Math.sqrt(ax*ax + ay*ay);

      // crash
      if(dv > CRASH_SPEED_DROP_MPS && aMag > CRASH_ACCEL_THRESH && (i - lastCrashIdx) > EVENT_MIN_GAP_IDX){
        lastCrashIdx = i;
        const lap = getLapForIndex(car, i);
        car.events.push({
          type:"crash",
          idx:i,
          lap,
          dv_mps: dv,
          accel: aMag,
          label:`Crash – Lap ${lap}, Δv ${(dv*2.23694).toFixed(1)} mph`
        });
        continue;
      }

      // collision
      if(dv > COLL_SPEED_DROP_MIN && dv <= COLL_SPEED_DROP_MAX && aMag > COLL_ACCEL_THRESH && (i - lastCollIdx) > EVENT_MIN_GAP_IDX){
        lastCollIdx = i;
        const lap = getLapForIndex(car, i);
        car.events.push({
          type:"collision",
          idx:i,
          lap,
          dv_mps: dv,
          accel: aMag,
          label:`Collision – Lap ${lap}, Δv ${(dv*2.23694).toFixed(1)} mph`
        });
      }
    }
  });

  // overtakes between cars (simple dist-based, same index)
  if(cars.length >= 2){
    const maxLen = Math.max(...cars.map(c=>c.data.length));
    const lastOvertake = {}; // key "i-j" -> last index
    for(let iIdx=0;iIdx<cars.length;iIdx++){
      for(let jIdx=iIdx+1;jIdx<cars.length;jIdx++){
        const key = `${iIdx}-${jIdx}`;
        lastOvertake[key] = -Infinity;
      }
    }

    for(let k=1;k<maxLen;k++){
      for(let iIdx=0;iIdx<cars.length;iIdx++){
        for(let jIdx=iIdx+1;jIdx<cars.length;jIdx++){
          const carA = cars[iIdx];
          const carB = cars[jIdx];
          if(k >= carA.data.length || k >= carB.data.length) continue;
          const prevA = carA.data[k-1].dist;
          const prevB = carB.data[k-1].dist;
          const curA  = carA.data[k].dist;
          const curB  = carB.data[k].dist;

          const key = `${iIdx}-${jIdx}`;
          if(prevA <= prevB && curA > curB && (k - lastOvertake[key]) > EVENT_MIN_GAP_IDX){
            lastOvertake[key] = k;
            const lap = getLapForIndex(carA, k);
            const label = `Overtake ${carA.name} → ${carB.name} (Lap ${lap})`;
            carA.events.push({ type:"overtake", idx:k, lap, label, with:carB.name });
            carB.events.push({ type:"overtake", idx:k, lap, label:`Got overtaken by ${carA.name} (Lap ${lap})`, with:carA.name });
          } else if(prevB <= prevA && curB > curA && (k - lastOvertake[key]) > EVENT_MIN_GAP_IDX){
            lastOvertake[key] = k;
            const lap = getLapForIndex(carB, k);
            const label = `Overtake ${carB.name} → ${carA.name} (Lap ${lap})`;
            carB.events.push({ type:"overtake", idx:k, lap, label, with:carA.name });
            carA.events.push({ type:"overtake", idx:k, lap, label:`Got overtaken by ${carB.name} (Lap ${lap})`, with:carB.name });
          }
        }
      }
    }
  }
}

function getLapForIndex(car, idx){
  const laps = car.lapStarts && car.lapStarts.length?car.lapStarts:[0];
  let lap = 1;
  for(let i=laps.length-1;i>=0;i--){
    if(idx >= laps[i]) { lap = i+1; break; }
  }
  return lap;
}

/* ---------- EVENT TIMELINE DRAWING ---------- */
function drawEventTimeline(){
  eventCtx.clearRect(0,0,eventCanvas.width,eventCanvas.height);
  if(!cars.length) return;

  const showCrash     = showCrashEl.checked;
  const showCollision = showCollisionEl.checked;
  const showOvertake  = showOvertakeEl.checked;
  const showFastLap   = showFastLapEl.checked;
  const showLapStart  = showLapStartEl.checked;

  const maxFrames = Math.max(...cars.map(c=>c.data.length));
  if(maxFrames <= 1) return;

  const padX = 30;
  const padY = 10;
  const innerW = eventCanvas.width - padX*2;
  const innerH = eventCanvas.height - padY*2;

  // baseline(s)
  eventCtx.strokeStyle = "#333";
  eventCtx.lineWidth = 1;

  if(timelineMode === 'unified'){
    const y = eventCanvas.height/2;
    eventCtx.beginPath();
    eventCtx.moveTo(padX,y);
    eventCtx.lineTo(eventCanvas.width-padX,y);
    eventCtx.stroke();

    cars.forEach((car,ci)=>{
      const baseY = y;
      car.events.forEach(ev=>{
        if(!eventTypeVisible(ev.type, showCrash,showCollision,showOvertake,showFastLap,showLapStart)) return;
        const tFrac = ev.idx / (maxFrames-1);
        const x = padX + tFrac * innerW;
        drawEventIcon(ev, car.color, x, baseY);
      });
    });

  } else {
    const rowH = innerH / cars.length;
    cars.forEach((car,ci)=>{
      const cy = padY + rowH*(ci+0.5);
      eventCtx.beginPath();
      eventCtx.moveTo(padX,cy);
      eventCtx.lineTo(eventCanvas.width-padX,cy);
      eventCtx.stroke();

      car.events.forEach(ev=>{
        if(!eventTypeVisible(ev.type, showCrash,showCollision,showOvertake,showFastLap,showLapStart)) return;
        const tFrac = ev.idx / (maxFrames-1);
        const x = padX + tFrac * innerW;
        drawEventIcon(ev, car.color, x, cy);
      });
    });
  }
}

/* Decide if event type is visible given filters */
function eventTypeVisible(type, showCrash,showCollision,showOvertake,showFastLap,showLapStart){
  if(type==="crash")      return showCrash;
  if(type==="collision")  return showCollision;
  if(type==="overtake")   return showOvertake;
  if(type==="fastestLap") return showFastLap;
  if(type==="lapStart")   return showLapStart;
  return false;
}

/* Draw "clean SVG-style" icons on canvas */
function drawEventIcon(ev, carColor, x, y){
  const ctx = eventCtx;
  const size = 7;

  switch(ev.type){
    case "crash": // red square
      ctx.fillStyle = "#ff4444";
      ctx.fillRect(x-size,y-size,size*2,size*2);
      break;
    case "collision": // orange circle
      ctx.beginPath();
      ctx.arc(x,y,size,0,Math.PI*2);
      ctx.fillStyle="#ffa500";
      ctx.fill();
      break;
    case "overtake": // green triangle
      ctx.beginPath();
      ctx.moveTo(x, y-size);
      ctx.lineTo(x-size, y+size);
      ctx.lineTo(x+size, y+size);
      ctx.closePath();
      ctx.fillStyle="#00ff66";
      ctx.fill();
      break;
    case "fastestLap": // purple diamond
      ctx.beginPath();
      ctx.moveTo(x, y-size);
      ctx.lineTo(x-size, y);
      ctx.lineTo(x, y+size);
      ctx.lineTo(x+size, y);
      ctx.closePath();
      ctx.fillStyle="#c000ff";
      ctx.fill();
      break;
    case "lapStart": // grey vertical bar
      ctx.strokeStyle="#bbbbbb";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.moveTo(x, y-size*1.5);
      ctx.lineTo(x, y+size*1.5);
      ctx.stroke();
      break;
    default:
      // fallback: small square in car color
      ctx.fillStyle = carColor;
      ctx.fillRect(x-size/2,y-size/2,size,size);
  }
}

/* ---------- EVENT TIMELINE INTERACTION ---------- */
eventCanvas.addEventListener("mousemove", e=>{
  const rect = eventCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const hit = findNearestEventAtPixel(x,y);
  if(hit){
    tooltipEl.style.display = "block";
    tooltipEl.style.left = (e.clientX+10)+"px";
    tooltipEl.style.top  = (e.clientY+10)+"px";
    tooltipEl.textContent = `${hit.car.name}: ${hit.ev.label || hit.ev.type} @ idx ${hit.ev.idx}`;
  } else {
    tooltipEl.style.display = "none";
  }
});

eventCanvas.addEventListener("mouseleave", ()=>{
  tooltipEl.style.display = "none";
});

eventCanvas.addEventListener("click", e=>{
  const rect = eventCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const hit = findNearestEventAtPixel(x,y,true);
  if(hit){
    const idx = hit.ev.idx;
    scrubber.value = idx;
    cars.forEach(car=>{
      car.dataIndex = Math.min(idx, car.data.length-1);
      updateCarTrackIndex(car);
    });
    updateDashboards();
    drawCars();
    drawEventTimeline();
  }
});

/* Find nearest event to pixel (x,y) */
function findNearestEventAtPixel(x,y,clickMode=false){
  if(!cars.length) return null;
  const maxFrames = Math.max(...cars.map(c=>c.data.length));
  const padX = 30;
  const padY = 10;
  const innerW = eventCanvas.width - padX*2;
  const innerH = eventCanvas.height - padY*2;

  const showCrash     = showCrashEl.checked;
  const showCollision = showCollisionEl.checked;
  const showOvertake  = showOvertakeEl.checked;
  const showFastLap   = showFastLapEl.checked;
  const showLapStart  = showLapStartEl.checked;

  let best=null;
  let bestDist=Infinity;

  if(timelineMode === 'unified'){
    const baseY = eventCanvas.height/2;
    cars.forEach(car=>{
      car.events.forEach(ev=>{
        if(!eventTypeVisible(ev.type, showCrash,showCollision,showOvertake,showFastLap,showLapStart)) return;
        const tFrac = ev.idx / (maxFrames-1);
        const ex = padX + tFrac*innerW;
        const ey = baseY;
        const dx = ex-x;
        const dy = ey-y;
        const dist = Math.sqrt(dx*dx+dy*dy);
        if(dist < bestDist){
          bestDist = dist;
          best = {car,ev,ex,ey};
        }
      });
    });
  } else {
    const rowH = innerH / cars.length;
    cars.forEach((car,ci)=>{
      const cy = padY + rowH*(ci+0.5);
      car.events.forEach(ev=>{
        if(!eventTypeVisible(ev.type, showCrash,showCollision,showOvertake,showFastLap,showLapStart)) return;
        const tFrac = ev.idx / (maxFrames-1);
        const ex = padX + tFrac*innerW;
        const ey = cy;
        const dx = ex-x;
        const dy = ey-y;
        const dist = Math.sqrt(dx*dx+dy*dy);
        if(dist < bestDist){
          bestDist = dist;
          best = {car,ev,ex,ey};
        }
      });
    });
  }

  const hoverRadius = clickMode ? 15 : 10;
  if(bestDist <= hoverRadius) return best;
  return null;
}

/* ---------- DEBUG HOOK ---------- */
window.__debug = { cars, masterTrack };
</script>
</body>
</html>
